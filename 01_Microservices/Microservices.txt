==================
Before Microservices
==================
1. Monolithic architecture: Mulitple components are combined in single large app.
2. Single Code Base
3. Deployed in single bundle
4. Drawbacks:- Change in one service then whole app is redeployed.
5. Building Problem:- Developers has to communicate
6. Problem in Scale(large codebase)
7. Cumbersome(extreme tedious) over time.

==================
Microservices
==================
1. Large apps are divide into small parts.
2. Different Codebase
3. Each module managed independently
4. Different tech stack
5. Drawback:- Handling microservices is complex.

==================
What we are going to build to Master Microservices
==================

1. We are creating three services :- Hotel Service, User Service, Rating Service
2. All 3 Services will use three different database for themselves.
3. We are using github config server in config service.
4. Client will directly communicate with api gateway and then services.
5. Providing Authentication with OKTA Auth.
6. We have to register all these servies in ServiceRegistery Services where all services are centrallized.
7. All Services will run at different port at runtime parallely on service registry.

===================
Creating User Microservice with storing data in MySQL database
===================

===================
Creating Hotel Microservice with storing data in PostgreSQL database
===================

===================
Creating Rating Microservice with storing data in MongoDB database
===================

===================
Implementing Serivce Registration(Eureka Service) and Discovery Client
===================
Definitions

Eureka Server
Eureka Server is also known as Discovery Server. It contains a registry of services and a REST api that can be used to register a service, deregister a service and knows all the client applications running on each port and IP address.

Eureka Service
Any application that can be found in the Eureka Server's registry and is discoverable by others. A service has a logical identifier called a "service id", that can refer to one or more instances of the same application.

Eureka Instance
Any application that registers itself with the Eureka Server to be discovered by others.

Eureka Client
Any application that can discover services

1. It will walkthrough you through the process of starting and using the Netflix Eureka service registry.
	1.1 It will track all the information of services.

2. We will set up a Netflix Eureka service registry and then build a client that both registers itself with the registry and uses it to resolve its own host.
	2.1 Add dependencies for Cloud Bootstrap and Eureka Server for the service application and Cloud Bootstrap, Eureka Server and Eureka Discovery Client for the client application.
	2.2 Spring Boot provides a Spring Boot Starter for a Eureka Server.
	2.3 Spring Boot also provides a starter for Eureka clients.

3. We first need a Eureka Service registry. We can use Spring Cloud’s @EnableEurekaServer to stand up a registry with which other applications can communicate. This is a regular Spring Boot application with one annotation (@EnableEurekaServer) added to enable the service registry in main Application at class level.

4. When the registry starts, it will complain (with a stacktrace) that there are no replica nodes to which the registry can connect. In a production environment, you will want more than one instance of the registry.For our simple purposes, however, it suffices to disable the relevant logging.

5. By default, the registry also tries to register itself, so you need to disable that behavior as well.

6. It is a good convention to put this registry on a separate port when using it locally.

7. Add some properties to eureka-service/src/main/resources/application.properties to handle all of these requirements, as the following listing shows:

server.port=8761

eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false

logging.level.com.netflix.eureka=OFF
logging.level.com.netflix.discovery=OFF

8. Now that we have started a service registry, we can stand up a client that both registers itself with the registry and uses the Spring Cloud DiscoveryClient abstraction to interrogate the registry for its own host and port. The @EnableDiscoveryClient activates the Netflix Eureka DiscoveryClient implementation.
	8.1 Discovery client service concept in spring cloud is implemented in different ways like Eureka, consul, zookeeper etc. If you are using Eureka by Netflix then @EnableEurekaClient is specifically for that. But if you are using any other service discovery including Eureka you can use @EnableDiscoveryClient.
	8.2 Add some properties to application.properties to handle all of these requirements, as the following listing shows:

spring.application.name=USER-SERVICE

eureka.instance.prefer-ip-address=true
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.client.service-url.defaultZone=http://localhost:8761/eureka

	8.3 Similarly we have to discover Hotel Service and Rating Service as Eureka Client Service.
	8.4 The eureka-client will take about a minute to register itself in the registry and to refresh its own list of registered instances from the registry.

=======================
How Microservices Communicate with each other ?
=======================
1. With the help of RestTemplate Class.
2. As of Spring Framework 5, alongside the WebFlux stack, Spring introduced a new HTTP client called WebClient.
3. WebClient is a modern, alternative HTTP client to RestTemplate. Not only does it provide a traditional synchronous API, but it also supports an efficient nonblocking and asynchronous approach.
4. That said, if we're developing new applications or migrating an old one, it's a good idea to use WebClient. Moving forward, RestTemplate will be deprecated in future versions.
5. First we will create a Bean of RestTemplate in our config class.
6. As per business, fetch ratings of the user in user service from rating-service with help of Rest Template Methods.
7. Calling Two Microservices Together rating service and hotel service.
Example Response:- 

{
    "userId": "65bf5d73-7498-459f-9be3-572a89bafd70",
    "name": "Pranay Singh",
    "email": "pranay@gmail.com",
    "about": "Software Engineer",
    "ratings": [
        {
            "ratingId": "2aa3d51a-dc24-48d9-a738-b3a5e5afe7a5",
            "userId": "65bf5d73-7498-459f-9be3-572a89bafd70",
            "hotelId": "59db9bc3-9eb4-4f11-b6fe-c91d6078cb6d",
            "rating": 9,
            "feedback": "This is one of the top hotels in india in terms of food and hospitality.",
            "hotel": {
                "id": "59db9bc3-9eb4-4f11-b6fe-c91d6078cb6d",
                "name": "Hotel Sayaji",
                "location": "Indore",
                "about": "Very good food and services"
            }
        }
    ]
}

====================
Loadbalance Across Server Instances or Removing Host and Port of Microservices
====================
1. In this, we are replacing hard code url's to dynamic url's so in this case if the host and port changes, the url will break.
Therefore we are using name of Discovery Client that is register in Discovery Server and replace it will static url's
ex:- localhost:8081 => USER-SERVICE

2. To create a fault-tolerant system, it's common to run multiple instances of each application.
Thus, whenever one service needs to communicate with another, it needs to pick a particular instance to send its request.
Load balancing is the process of distributing traffic among different instances of the same application.

A load balancer acts as the “traffic cop” sitting in front of your servers and routing client requests 
across all servers capable of fulfilling those requests in a manner that maximizes speed and capacity 
utilization and ensures that no one server is overworked, which could degrade performance.

Therefore, we applied @LoadBalanced annotation at our RestTemplate Bean created in config class.
