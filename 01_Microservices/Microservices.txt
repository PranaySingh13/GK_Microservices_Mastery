==================
Before Microservices
==================
1. Monolithic architecture: Mulitple components are combined in single large app.
2. Single Code Base
3. Deployed in single bundle
4. Drawbacks:- Change in one service then whole app is redeployed.
5. Building Problem:- Developers has to communicate
6. Problem in Scale(large codebase)
7. Cumbersome(extreme tedious) over time.

==================
Microservices
==================
1. Large apps are divide into small parts.
2. Different Codebase
3. Each module managed independently
4. Different tech stack
5. Drawback:- Handling microservices is complex.

==================
What we are going to build to Master Microservices
==================

1. We are creating three services :- Hotel Service, User Service, Rating Service
2. All 3 Services will use three different database for themselves.
3. We are using github config server in config service.
4. Client will directly communicate with api gateway and then services.
5. Providing Authentication with OKTA Auth.
6. We have to register all these servies in ServiceRegistery Services where all services are centrallized.
7. All Services will run at different port at runtime parallely on service registry.

===================
Creating User Microservice with storing data in MySQL database
===================

===================
Creating Hotel Microservice with storing data in PostgreSQL database
===================

===================
Creating Rating Microservice with storing data in MongoDB database
===================

===================
Implementing Serivce Registration(Eureka Service) and Discovery Client
===================
Definitions

Eureka Server
Eureka Server is also known as Discovery Server. It contains a registry of services and a REST api that can be used to register a service, deregister a service and knows all the client applications running on each port and IP address.

Eureka Service
Any application that can be found in the Eureka Server's registry and is discoverable by others. A service has a logical identifier called a "service id", that can refer to one or more instances of the same application.

Eureka Instance
Any application that registers itself with the Eureka Server to be discovered by others.

Eureka Client
Any application that can discover services

1. It will walkthrough you through the process of starting and using the Netflix Eureka service registry.
	1.1 It will track all the information of services.

2. We will set up a Netflix Eureka service registry and then build a client that both registers itself with the registry and uses it to resolve its own host.
	2.1 Add dependencies for Cloud Bootstrap and Eureka Server for the service application and Cloud Bootstrap, Eureka Server and Eureka Discovery Client for the client application.
	2.2 Spring Boot provides a Spring Boot Starter for a Eureka Server.
	2.3 Spring Boot also provides a starter for Eureka clients.

3. We first need a Eureka Service registry. We can use Spring Cloud’s @EnableEurekaServer to stand up a registry with which other applications can communicate. This is a regular Spring Boot application with one annotation (@EnableEurekaServer) added to enable the service registry in main Application at class level.

4. When the registry starts, it will complain (with a stacktrace) that there are no replica nodes to which the registry can connect. In a production environment, you will want more than one instance of the registry.For our simple purposes, however, it suffices to disable the relevant logging.

5. By default, the registry also tries to register itself, so you need to disable that behavior as well.

6. It is a good convention to put this registry on a separate port when using it locally.

7. Add some properties to eureka-service/src/main/resources/application.properties to handle all of these requirements, as the following listing shows:

server.port=8761

eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false

logging.level.com.netflix.eureka=OFF
logging.level.com.netflix.discovery=OFF

8. Now that we have started a service registry, we can stand up a client that both registers itself with the registry and uses the Spring Cloud DiscoveryClient abstraction to interrogate the registry for its own host and port. The @EnableDiscoveryClient activates the Netflix Eureka DiscoveryClient implementation.
	8.1 Discovery client service concept in spring cloud is implemented in different ways like Eureka, consul, zookeeper etc. If you are using Eureka by Netflix then @EnableEurekaClient is specifically for that. But if you are using any other service discovery including Eureka you can use @EnableDiscoveryClient.
	8.2 Add some properties to application.properties to handle all of these requirements, as the following listing shows:

spring.application.name=USER-SERVICE

eureka.instance.prefer-ip-address=true
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.client.service-url.defaultZone=http://localhost:8761/eureka

	8.3 Similarly we have to discover Hotel Service and Rating Service as Eureka Client Service.
	8.4 The eureka-client will take about a minute to register itself in the registry and to refresh its own list of registered instances from the registry.

=======================
How Microservices Communicate with each other ?
=======================
1. With the help of RestTemplate Class.
2. As of Spring Framework 5, alongside the WebFlux stack, Spring introduced a new HTTP client called WebClient.
3. WebClient is a modern, alternative HTTP client to RestTemplate. Not only does it provide a traditional synchronous API, but it also supports an efficient nonblocking and asynchronous approach.
4. That said, if we're developing new applications or migrating an old one, it's a good idea to use WebClient. Moving forward, RestTemplate will be deprecated in future versions.
5. First we will create a Bean of RestTemplate in our config class.
6. As per business, fetch ratings of the user in user service from rating-service with help of Rest Template Methods.
7. Calling Two Microservices Together rating service and hotel service.
Example Response:- 

{
    "userId": "65bf5d73-7498-459f-9be3-572a89bafd70",
    "name": "Pranay Singh",
    "email": "pranay@gmail.com",
    "about": "Software Engineer",
    "ratings": [
        {
            "ratingId": "2aa3d51a-dc24-48d9-a738-b3a5e5afe7a5",
            "userId": "65bf5d73-7498-459f-9be3-572a89bafd70",
            "hotelId": "59db9bc3-9eb4-4f11-b6fe-c91d6078cb6d",
            "rating": 9,
            "feedback": "This is one of the top hotels in india in terms of food and hospitality.",
            "hotel": {
                "id": "59db9bc3-9eb4-4f11-b6fe-c91d6078cb6d",
                "name": "Hotel Sayaji",
                "location": "Indore",
                "about": "Very good food and services"
            }
        }
    ]
}

====================
Loadbalance Across Server Instances or Removing Host and Port of Microservices
====================
1. In this, we are replacing hard code url's to dynamic url's so in this case if the host and port changes, the url will break.
Therefore we are using name of Discovery Client that is register in Discovery Server and replace it will static url's
ex:- localhost:8081 => USER-SERVICE

2. To create a fault-tolerant system, it's common to run multiple instances of each application.
Thus, whenever one service needs to communicate with another, it needs to pick a particular instance to send its request.
Load balancing is the process of distributing traffic among different instances of the same application.

A load balancer acts as the “traffic cop” sitting in front of your servers and routing client requests 
across all servers capable of fulfilling those requests in a manner that maximizes speed and capacity 
utilization and ensures that no one server is overworked, which could degrade performance.

Therefore, we applied @LoadBalanced annotation at our RestTemplate Bean created in config class.

====================
Feign Client
====================
1. Feign is a declarative web service client developed by Netflix.
2. It makes writing web service clients easier.
3. If you want to use Feign,create an interface and annotate it with @FeignClient.
4. It has pluggable annotation support including Feign annotations and JAX-RS annotations. Feign also supports pluggable encoders and decoders.
5. Spring Cloud adds support for Spring MVC annotations and for using the same HttpMessageConverters used by default in Spring Web.
6. Spring Cloud integrates Eureka, Spring Cloud CircuitBreaker, as well as Spring Cloud LoadBalancer to provide a load-balanced http client when using Feign.
7. To include Feign in your project use the starter with group org.springframework.cloud and artifact id spring-cloud-starter-openfeign to our pom.xml file.
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

8. Next, we need to add @EnableFeignClients to our main class.
9. Next, create an interface HotelService and annotate it with @FeignClient.
10. Inject the HotelService interface in UserServiceImpl to use its methods.
11. The load-balancer client above will want to discover the physical addresses for the "HOTEL-SERVICE" service. 
If your application is a Eureka client then it will resolve the service in the Eureka service registry. 
If you don’t want to use Eureka, you can configure a list of servers in your external configuration using SimpleDiscoveryClient.

@FeignClient(name = "HOTEL-SERVICE")
public interface HotelService {

	@GetMapping("/api/hotels/hotel/{hotelId}")
	Hotel getHotel(@PathVariable String hotelId);
}

12. As per requirement, we can POST,PUT,DELETE,GET HTTP Calls of multiple discovery client services with the help of Feign Client.

====================
Spring Cloud API Gateway
====================
What is the use of an API Gateway in Microservices ?

1. If we divide API services that we could use in here with depending on that we used microservices based architecture,
there will be 4 main services to consume in order to load a view,
Ex: 
User addresses – User service
Promotions – promotions service
Products Details – Product service
Payment details and calculations – Payments service

So If I’m the frontend developer who consumes this API as a client, I need to call multiple backend services, Just to load this view. 
There are two ways of calling those APIS.
	
	1.1 Direct client-microservice communication. – As a theory, we could call any directly from a client. But here there are few issues 
	like hard to refactor microservices since those services are directly accessing by clients, some services might use protocols that are 
	not web‑friendly, Hence there are really minimal places that we can see they are using a direct client to microservice communication in modern applications.

	1.2 API gateway microservice communication. – This is the most common practice in building communication between clients to service in microservices. 
	In API Gateway there will be a single entry point to access services, and It encapsulates the internal system and return an API that tailored for clients.
	
=====================
Implementing Spring Cloud API Gateway
=====================
1. If you are building an API gateway for your own project, Just add the following libraries and create a spring boot application.
Add dependencies for Cloud Bootstrap, Eureka Discovery Client,Gateway and Spring Reactive Web from Spring Initializer.

2. Next, we need to add @EnableEurekaClient to our main class.

3. Next, Then add configurations to connect with the service registry.

server.port=8084
spring.application.name=API-GATEWAY

eureka.instance.prefer-ip-address=true
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.client.service-url.defaultZone=http://localhost:8761/eureka

4. Next, Configuring API Gateway Routes With Spring Cloud Gateway.
	4.1 As I discussed earlier on Service Registration and Discovery With Spring Cloud Netflix Eureka for the moment we have enabled service discovery for this service collection. Hence we can use that discovery capability to build routing inside the microservice ecosystem using spring cloud gateway.
	4.2 when a client sends a request to the API gateway, It will discover the correct service IP and PORT using the service registry to communicate and route the request.
 	4.3 So just add following configurations in to the API gateway application properties for all discovery client services.

##GATEWAY CONFIGURATIONS
spring:
  application:
    name: API-GATEWAY
  cloud:
    gateway:
      routes:

## USER SERVICE
      - id: USER-SERVICE
        uri: lb://USER-SERVICE
        predicates:
        - Path= /api/users/

	4.4 lb in uri indicates that our client services are load balanced.
	4.5 If you are using application.properties define all the routes as below,

spring.cloud.gateway.routes[0].id=user-service
spring.cloud.gateway.routes[0].uri=lb://user-service
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/users/**
spring.cloud.gateway.routes[0].filters[0]=StripPrefix=1

	4.6 What are the properties that we set for API gateway routes ?
		4.6.1 id – This is just an identification of the routes. You are free to use any kind of alphanumeric value here and I’m going to use the service name which I’ve defined in destination service.
		4.6.2 URI – Here we can use both http://localhost:8081 and lb://user-service, But if we need to use the inbuilt load balancer on Netflix Eureka server, we should use lb://user-service, 
			Then API registry will takeover the request and show load-balanced request destination to the API gateway.
		4.6.3 predicates – In here we can set multiple paths to identify a correct routing destination.
		4.6.4 filters – Here, you can modify requests and responses before or after sending the downstream request.
	4.7 Now we are ready with our API gateway + routing setup.

5. Calling from API Gateway port  
Example:- 
Request:- http://localhost:8084/api/users/user/65bf5d73-7498-459f-9be3-572a89bafd70

Response:- 
{
    "userId": "65bf5d73-7498-459f-9be3-572a89bafd70",
    "name": "Pranay Singh",
    "email": "pranay@gmail.com",
    "about": "Software Engineer",
    "ratings": [
        {
            "ratingId": "2aa3d51a-dc24-48d9-a738-b3a5e5afe7a5",
            "userId": "65bf5d73-7498-459f-9be3-572a89bafd70",
            "hotelId": "59db9bc3-9eb4-4f11-b6fe-c91d6078cb6d",
            "rating": 9,
            "feedback": "This is one of the top hotels in india in terms of food and hospitality.",
            "hotel": {
                "id": "59db9bc3-9eb4-4f11-b6fe-c91d6078cb6d",
                "name": "Hotel Sayaji",
                "location": "Indore",
                "about": "Very good food and services"
            }
        }
    ]
}

6. Important:- Refer the document for Spring Cloud Gateway on https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/

7. If we want to configuring multiple url of microservice in API Gateway.
Ex:- In hotel service ,if there is some other staff service than we have to give the staff service controller url to predicate path attribute in api gateway application.yml
#HOTEL SERVICE              
      - id: HOTEL-SERVICE
        uri: lb://HOTEL-SERVICE
        predicates:
        - Path= /api/hotels/**,/api/staffs/**